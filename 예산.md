# 예산
## 내 풀이
```js
const sum = (array) => return array.reduce((a,b)=> a+b) // 타입 같아서, 빈 배열일 경우에 sum 안함

function solution(d, budget) {

    const result = d.sort((a,b) => (a-b))
                    .findIndex((e,i) => sum(d.slice(0,i+1)) > budget)
    return result !== -1 ? result : d.length;
    
}
```

## 삽질과정
```
// # psudo (삽질 1)
// input input output
[1,3,2,5,4] 9 3
[2,2,3,3] 10 4
[1,2,3,4,5]
	array.length C 1 sum() == budget return (새롭게 생성된) array.length
    array.length C 2 sum() == budget
    .
    .
    .
    array.length C array.length sum() == budget
```
처음에 컴비네이션(조합)을 사용하려고 했었다. 우선 배열에서 n개만큼 뽑아서 모두 더한 값이 output과 같다면 그 때 뽑은 number의 개수를 리턴해주면 되는 것이라고 생각했기 떄문이다~
하지만 컴비네이션을 하게 되면 경우의 수가 4!이기 때문에 input 배열의 길이가 너무 길어지게 되면 n!로 너무 많은 연산을 하게 되어 속도가 느려지게 되고, **굳이 큰 수를 포함하는지 확인하지 않아도 되기 때문에** 컴비네이션은 굳이 사용할 필요가 없는 것 같다. 

조합을 이용한 다른 분의 풀이를 보았는데 왜인지 몰라도 테스트 케이스를 통과하지 못하는 경우를 보았다.(이거 생각하다가 또 산으로 갈것같아서 일단 여기서 마무리)


그리고 문제 조건을 다시 보면, 가장 많은 부서에게 예산을 지원해야 하므로 예산이 많이 드는 부서는 가장 마지막에 고려해도 된다!
input
[1,3,2,11] 6 

output

3

이라면, 먼저 작은 수를 뽑을 것이다. [(1,2),(1,3),(1,11)] ... (1,2,3)

그런데 (1,2,3)이 가장 많은 부서에게 예산을 지원할 수 있으므로 (1,11)은 우선순위에서 밀린다.

그래서 sort()를 해주는 것이다~~

[1,2,3,11] 이 상태에서 작은 수로 최대의 예산을 지원할 수 있는 경우를 고려하면 되므로 오름차순 정렬이 필요한 것임(두 번 말함, 강조)

나중에 보면 또 모를 것 같은 나를 위한 예시(ㅋㅋ)
[1,3,2,5] 6 2
4C1+4C2+4C3+4C4
4+12+4+4 = 24

아무튼 컴비네이션 삽질 썰은 여기서 마무리하고 psudocode를 다시 작성해보았다~

```js
// 1~array.length를 뽑을 건데
    // sort를 시켰으니까 가장 작은 것 부터 뽑음.
    // 순서대로 sum(0,1) < budget 루프를 돈다
    // sum(0,1,2) < budget 루프를 돈다
    // sum(0,1,2,3) == budget 루프가 끝난다
```
이를 이용해서 반복문을 작성한
## 탐토님 풀이1

```js
function solution(d, budget) {
    d.sort((a,b) => a-b)
    let acc = 0
    for (let i = 0; i < d.length; i++){
        acc += d[i];
        if (acc > budget) return i;
    }
    return d.length;
}
```
그런데 내 풀이 해설을 좀 더 달자면...(의식의 흐름대로 쓰는 중)


```js
const sum = (array) => return array.reduce((a,b)=> a+b) // 타입 같아서, 빈 배열일 경우에 sum 안함

function solution(d, budget) {

    const result = d.sort((a,b) => (a-b))
                    .findIndex((e,i) => sum(d.slice(0,i+1)) > budget)
    return result !== -1 ? result : d.length;
    
}
```

이거 js로 하니까 불편한 점이 한 두개가 아님
일단 킹받는점
1. sum 구현 파이썬처럼 내장함수 내놔
2. sort 오름차순 정렬을 위해서 (a-b)를 해줘야한다는거 파이썬처럼 알잘딱깔센 오름차순 디폴트로 해주지..서운...
3. 파이프 연산자가 없어서... 값을 "넘겨주는" 식의 가독성이 떨어짐 굳이비 sum(), d.slice이렇게 해주는거 킹받아요


아 ~~~파이썬 말린다~~~

무튼...내풀이를 다시 쓰자면...
일단 쿠쿠루삥뽕 오름차순 정렬을 하고 배열을 잘라서 인덱스가 0번부터 시작하니까...1부터 자르기 위해서 i+1을 인자로 넘겨주고... 자름... 그리고 그 자른 배열의 총합이 예산보다 큰 경우의 인덱스를 찾는 것임... 근데 만약 만족하는 인덱스가 없다? 그러면 -1을 반환하므로... d.length를 반환하면 되는것임... 갑자기 파이썬에 진 것 같아서 시무룩해짐...

파이썬으로 다시 써보기로 함...
